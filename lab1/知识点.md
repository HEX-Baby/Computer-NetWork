# 流程图
  
### 服务端主控模块流程图
```
      (  开始  )
          |
          V
  [ 初始化网络库 ]
          |
          V
[ 创建并绑定监听Socket ]
          |
          V
  [ 开始监听端口 ]
          |
          V
+----< 循环开始 <----+
|         |         |
|         V         |
|  [ 接受客户端连接 ] |
|         |         |
|         V         |
| < 连接是否成功? > | --否--+
|    |    是        |     |
|    V              |     |
| [ 为其创建新线程 ]--+-----+
+-------------------+
```
  
### 服务端客户端处理模块流程图
```
     (  线程开始  )
           |
           V
     [ 接收登录包 ]
           |
           V
  [ 记录用户名, 加入列表 ]
           |
           V
 [ 广播"XXX加入"系统消息 ]
           |
           V
+----< 消息循环 <----+
|          |         |
|          V         |
|    [ 接收新数据 ]   |
|          |         |
|          V         |
| < 连接是否正常? > --否--> [ 广播"XXX离开" ] --+
|     |    是        |                      |
|     V              |                      V
|  < 是何种消息? >   |                 [ 从列表移除 ]
|   |       |        |                      |
| 聊天      登出     |                      V
|   |        |       |                  ( 线程结束 )
|   V        +------>+
| [ 构建广播包, 调用广播模块 ]
+--------------------+
```
  
### 客户端主控/用户输入模块流程图
```
      (  开始  )
          |
          V
  [ 初始化网络库 ]
          |
          V
[ 创建Socket, 连接服务器 ]
          |
          V
  [ 获取昵称, 发送登录包 ]
          |
          V
 [ 创建后台消息接收线程 ]
          |
          V
+----< 用户输入循环 <----+
|          |           |
|          V           |
|   [ 等待键盘输入 ]    |
|          |           |
|          V           |
| < 输入是否为"exit"? > --是--> [ 发送登出包 ] --+
|     |    否          |                     |
|     V                |                     V
| [ 打包聊天消息并发送 ] |                   [ 清理资源 ]
+----------------------+                     |
                                             V
                                           ( 结束 )
```
  
### 客户端消息接收模块流程图
```
     (  线程开始  )
           |
           V
+----< 消息循环 <----+
|          |         |
|          V         |
|    [ 接收新数据 ]   |
|          |         |
|          V         |
| < 连接是否正常? > --否--> [ 通知主线程断开 ] --+
|     |    是        |                      |
|     V              |                      V
| [ 解析消息头和体 ]   |                    ( 线程结束 )
|          |         |
|          V         |
| [ 转换编码并显示 ]   |
+--------------------+
```
  
# 文件目录
```
ChatSolution/
├── ChatClient/
│   ├── protocol.h
│   └── ChatClient.cpp
│
├── ChatServer/
│   ├── protocol.h
│   └── ChatServer.cpp
│
└── x64/
    └── Debug/
        ├── ChatClient.exe
        └── ChatServer.exe
```

## `sockaddr_in` 结构体内部图解
```
sockaddr_in
+---------------------------------------------------+
| sin_family : short         | AF_INET (IPv4)       |
+---------------------------------------------------+
| sin_port   : unsigned short| 8080 (htons转换后)   |
+---------------------------------------------------+
| sin_addr   : struct in_addr| 存储二进制IP地址     |
|   └── S_un.S_addr          | 0x7F000001 (127.0.0.1)|
+---------------------------------------------------+
| sin_zero[8] : char[8]      | 填 0 (保留字节)      |
+---------------------------------------------------+
```

## `Socket` 与地址之间的关系
```
操作系统 Socket 表（简化示意）
┌────────────────────────────────────────────────────────┐
│ SOCKET 句柄  | 本地IP:端口        | 远端IP:端口          │
├────────────────────────────────────────────────────────┤
│  512 (sock_) | 192.168.1.10:52314 | 192.168.1.200:8080 │
└────────────────────────────────────────────────────────┘
```

## 三次握手
```
客户端（Client）                          服务器（Server）
    |                                           |
    | ------- SYN, seq=x ---------------------> |   （第一次握手）
    |                                           |
    | <---- SYN+ACK, seq=y, ack=x+1 ----------- |   （第二次握手）
    |                                           |
    | ------- ACK, ack=y+1 --------------------> |   （第三次握手）
    |                                           |
连接建立成功 ✅

```
| 步骤 | 发送方 | 报文内容                    | 含义       |
| -- | --- | ----------------------- | -------- |
| 1  | 客户端 | SYN, seq=x              | 请求建立连接   |
| 2  | 服务器 | SYN+ACK, seq=y, ack=x+1 | 同意并确认请求  |
| 3  | 客户端 | ACK, ack=y+1            | 确认连接建立成功 |

## recv和send是什么函数
`recv()` 和 `send()` 是网络编程中最核心的两个函数 —— 它们负责在 TCP 或 UDP 套接字上传输数据。

#### 基本定义
这两个函数都定义在 `<winsock2.h>`
```
int send(SOCKET s, const char *buf, int len, int flags);
int recv(SOCKET s, char *buf, int len, int flags);
```

| 参数      | 含义                              |
| ------- | ------------------------------- |
| `s`     | 套接字（Socket）句柄，用来标识当前连接          |
| `buf`   | 指向要发送/接收数据的缓冲区                  |
| `len`   | 缓冲区大小（发送时是要发送的字节数；接收时是最大可接收字节数） |
| `flags` | 标志位（通常为 `0`，可以用其他值设置特殊行为）       |


## Thread

std::thread 是 C++11 提供的线程类，可以用它创建新线程执行函数。

#### 构造和启动线程
```
// 创建线程并执行成员函数 recv_loop
recv_thread_ = std::thread(&ChatClient::recv_loop, this);
```
创建一个新线程，在后台执行 `ChatClient` 类的成员函数 `recv_loop()`。

```
主线程（GUI或main）
│
│  recv_thread_ = std::thread(&ChatClient::recv_loop, this)
│       创建新线程
└────► 新线程开始执行 recv_loop()
        │
        ├─> 循环接收服务器消息
        └─> 调用 handle_message() 处理消息
```
#### 3️⃣ 常用函数
| 函数         | 作用                            |
| ---------- | ----------------------------- |
| `join()`   | 等待线程结束并回收资源（阻塞调用线程直到目标线程完成）   |
| `detach()` | 让线程独立运行，结束后自动释放资源（不可再 `join`） |
| 构造函数       | 创建并启动线程，绑定函数和参数               |

```
if (recv_thread_.joinable()) {
    recv_thread_.join();
}
```
- `joinable()` → 检查线程是否可 join（是否正在运行或未回收）

- `join()` → 等待接收线程结束，保证线程安全退出

## 互斥锁Mutex

`mutex` 用于线程同步，保证同一时间只有一个线程访问共享资源。

```
lock_guard<mutex> lock(send_mutex_);
send(sock_, msg_str.c_str(), (int)msg_str.size(), 0);
```
防止多个线程同时调用 `send()`导致数据冲突。

#### 常用函数
| 函数                       | 作用                         |
| ------------------------ | -------------------------- |
| `lock()`                 | 上锁，其他线程必须等待解锁              |
| `unlock()`               | 解锁，允许其他线程获取锁               |
| `try_lock()`             | 尝试获取锁，获取失败返回 false         |
| `std::lock_guard<mutex>` | RAII 风格自动上锁/解锁，防止忘记 unlock |

| 成员变量                  | 类型          | 用途                           |
| --------------------- | ----------- | ---------------------------- |
| `thread recv_thread_` | std::thread | 后台接收服务器消息                    |
| `mutex send_mutex_`   | std::mutex  | 确保多线程发送消息时不会同时操作 socket 导致冲突 |

# protocol.h知识点

```c
// 使用 #pragma pack(push, 1) 指令，确保编译器按1字节对齐。
// 这对于网络编程至关重要，可以防止因编译器内存对齐优化
// 导致结构体在发送端和接收端大小不一致的问题。
#pragma pack(push, 1)
```

| 指令                      | 作用                    |
| ----------------------- | --------------------- |
| `#pragma pack(n)`       | 设置对齐边界为 n（例如 1、2、4、8） |
| `#pragma pack(push, n)` | 将当前对齐设置保存，并设置为 n      |
| `#pragma pack(pop)`     | 恢复之前保存的对齐设置           |
| `#pragma pack()`        | 恢复为默认对齐方式             |


```c
#pragma pack(push, 1)
struct A {
    char c;
    int  i;
};
#pragma pack(pop)
```

这段指令告诉编译器：

    “从这里开始，所有结构体都按 1 字节对齐。”

也就是说，**不再自动填充空隙字节（padding）。**

结果：

- c 占第 0 字节；

- i 紧接着放在第 1 字节；

- 结构体总长度 = 1 + 4 = 5 字节（没有对齐填充）。

| 成员 (Member) | 类型 (Type)   | 作用与说明                                                      |
| ----------- | ----------- | ---------------------------------------------------------- |
| msgType     | MessageType | 4字节。用于标识当前消息的类型，接收方根据此字段来决定如何解析后续的 body。                   |
| bodySize    | uint32_t    | 4字节。表示紧跟在 MessageHeader 之后的消息体的总长度（以字节为单位）。如果消息没有消息体，此值为0。 |


| 成员 (Member) | 类型 (Type) | 作用与说明                                                                  |
| ----------- | --------- | ---------------------------------------------------------------------- |
| username    | char[32]  | 32字节。用于存放客户端希望使用的用户名。它是一个以 `\0` 结尾的 C 风格字符串，最大长度为 31 个字符（留一个位置给 `\0`）。 |


| 成员 (Member) | 类型 (Type) | 作用与说明                                                   |
| ----------- | --------- | ------------------------------------------------------- |
| timestamp   | int64_t   | 8字节。消息的时间戳，通常由服务器在收到或转发消息时生成，可以使用 `time(0)` 或更高精度的时间函数。 |
| username    | char[32]  | 32字节。发送这条聊天消息的用户名，同样是以 `\0` 结尾的字符串。                     |


# ChatClient.cpp知识点


---

### 🧩 Winsock 初始化与清理

| 函数                                                            | 参数                  | 类型          | 说明                                                | 返回值                            |
| ------------------------------------------------------------- | ------------------- | ----------- | ------------------------------------------------- | ------------------------------ |
| `int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData)` | `wVersionRequested` | `WORD`      | 指定所需 Winsock 版本号（通常使用 `MAKEWORD(2, 2)` 表示 2.2 版）。 | 返回 0 表示成功，非 0 表示失败。            |
|                                                               | `lpWSAData`         | `LPWSADATA` | 指向 `WSADATA` 结构体的指针，用于接收 Winsock 的配置信息。           | —                              |
| `int WSACleanup(void)`                                        | —                   | —           | 释放 Winsock 库资源，终止使用。                              | 返回 0 表示成功，`SOCKET_ERROR` 表示失败。 |

---

### 🔄 Socket 生命周期

| 函数                                                                | 参数         | 类型                       | 说明                                               | 返回值                                     |
| ----------------------------------------------------------------- | ---------- | ------------------------ | ------------------------------------------------ | --------------------------------------- |
| `SOCKET socket(int af, int type, int protocol)`                   | `af`       | `int`                    | 地址族（常用 `AF_INET` 表示 IPv4）。                       | 成功返回 `SOCKET` 句柄，失败返回 `INVALID_SOCKET`。 |
|                                                                   | `type`     | `int`                    | 套接字类型（`SOCK_STREAM` 表示 TCP，`SOCK_DGRAM` 表示 UDP）。 | —                                       |
|                                                                   | `protocol` | `int`                    | 通常为 0，表示自动选择默认协议。                                | —                                       |
| `int connect(SOCKET s, const struct sockaddr* name, int namelen)` | `s`        | `SOCKET`                 | 已创建的套接字。                                         | 成功返回 0，失败返回 `SOCKET_ERROR`。             |
|                                                                   | `name`     | `const struct sockaddr*` | 指向目标服务器的地址结构（如 `sockaddr_in`）。                   | —                                       |
|                                                                   | `namelen`  | `int`                    | 地址结构的长度（通常为 `sizeof(sockaddr_in)`）。              | —                                       |
| `int send(SOCKET s, const char* buf, int len, int flags)`         | `s`        | `SOCKET`                 | 已连接的套接字。                                         | 返回实际发送的字节数，失败返回 `SOCKET_ERROR`。         |
|                                                                   | `buf`      | `const char*`            | 指向要发送的数据缓冲区。                                     | —                                       |
|                                                                   | `len`      | `int`                    | 缓冲区长度（字节数）。                                      | —                                       |
|                                                                   | `flags`    | `int`                    | 通常为 0（可选标志）。                                     | —                                       |
| `int recv(SOCKET s, char* buf, int len, int flags)`               | `s`        | `SOCKET`                 | 已连接的套接字。                                         | 返回接收的字节数，0 表示连接关闭，失败返回 `SOCKET_ERROR`。  |
|                                                                   | `buf`      | `char*`                  | 指向接收缓冲区。                                         | —                                       |
|                                                                   | `len`      | `int`                    | 缓冲区长度。                                           | —                                       |
|                                                                   | `flags`    | `int`                    | 通常为 0（可选标志）。                                     | —                                       |
| `int closesocket(SOCKET s)`                                       | `s`        | `SOCKET`                 | 要关闭的套接字。                                         | 成功返回 0，失败返回 `SOCKET_ERROR`。             |

---

### ⚙️ 库链接

| 指令                                   | 参数             | 类型    | 说明                                  |
| ------------------------------------ | -------------- | ----- | ----------------------------------- |
| `#pragma comment(lib, "ws2_32.lib")` | `"ws2_32.lib"` | 字符串常量 | 告诉编译器自动链接 Winsock 动态库，无需在项目属性中手动添加。 |

---



---

### 🧩 UI 线程与接收线程分离

| 线程                       | 主要职责                 | 说明                                                     |
| ------------------------ | -------------------- | ------------------------------------------------------ |
| 主线程 (`main`)             | 处理用户输入并发送消息 (`send`) | 如果将接收操作 (`recv`) 放在主线程，当没有新消息时 `recv` 会阻塞，导致程序卡死、无法输入。 |
| 接收线程 (`ReceiveMessages`) | 专门负责接收服务器消息 (`recv`) | 在子线程中循环调用阻塞的 `recv`，即便没有新消息也只会阻塞该线程，不影响主线程响应用户输入。      |

---

### ⚙️ 线程创建与管理

| 操作   | 语法                                                       | 说明                                                        |
| ---- | -------------------------------------------------------- | --------------------------------------------------------- |
| 创建线程 | `std::thread recvThread(ReceiveMessages, serverSocket);` | 使用 C++11 的 `std::thread` 创建一个新线程，执行 `ReceiveMessages` 函数。 |
| 分离线程 | `recvThread.detach();`                                   | 将子线程与主线程分离，使其在后台独立运行。主线程无需等待其结束，子线程会在完成或程序退出时自动终止。        |

---

### 🔄 线程同步与通信

| 元素              | 类型                  | 说明                                                                    |
| --------------- | ------------------- | --------------------------------------------------------------------- |
| `g_isConnected` | `std::atomic<bool>` | 全局原子变量，用作线程间的连接状态标志。`atomic` 确保多线程下的读写安全，避免数据竞争。                      |
| 使用方式            | —                   | 当任意线程检测到连接断开时，将 `g_isConnected` 设为 `false`；另一个线程可安全读取此状态并退出循环，实现优雅终止。 |

---

清晰展示了平台特性、问题、解决方案与编码转换过程👇

---

### 🧩 平台特性说明

| 项目        | 说明                                                                                          |
| --------- | ------------------------------------------------------------------------------------------- |
| **平台相关性** | 该部分是代码中最具 **Windows 平台特性** 的部分，主要用于在 Windows 控制台（CMD）中正确显示中文、emoji 等非 ASCII 字符。             |
| **根本问题**  | 网络传输标准使用 **UTF-8**，但 Windows 控制台默认使用 **GBK (代码页 936)**，同时底层 API 更适合处理 **UTF-16 (wchar_t)**。 |
| **结果**    | 若不做转换，输出会出现乱码或表情无法显示。                                                                       |

---

### ⚙️ 解决方案概览

| 步骤              | 方法 / API                                                                              | 说明                                                            |
| --------------- | ------------------------------------------------------------------------------------- | ------------------------------------------------------------- |
| **1. 设置控制台模式**  | `_setmode(_fileno(stdout), _O_U16TEXT);` <br> `_setmode(_fileno(stdin), _O_U16TEXT);` | 将标准输入/输出切换到 UTF-16 模式，使 `wcout` / `wcin` 支持宽字符流。              |
| **2. 内部使用宽字符串** | `std::wstring`                                                                        | 程序内部所有与控制台交互的字符串均使用 `std::wstring` 类型（UTF-16）。                |
| **3. 发送前编码转换**  | `WideCharToMultiByte()`                                                               | 将 UTF-16 的 `wstring` 转换为 UTF-8 的 `string`，再通过 `send()` 发送到网络。 |
| **4. 接收后编码转换**  | `MultiByteToWideChar()`                                                               | 将从网络接收到的 UTF-8 `string` 转换为 UTF-16 `wstring`，再通过 `wcout` 输出。  |

---

### 🔄 编码转换流程

| 阶段       | 数据方向             | 编码                                       | 处理方式                       |
| -------- | ---------------- | ---------------------------------------- | -------------------------- |
| **输入阶段** | 用户输入 → 程序        | UTF-16 (`wcin` → `wstring`)              | 控制台直接支持宽字符输入。              |
| **发送阶段** | `wstring` → 网络传输 | UTF-8 (`WideCharToMultiByte`)            | 将宽字符串转换为 UTF-8 字节序列后发送。    |
| **接收阶段** | 网络 → 程序          | UTF-8 (`recv`)                           | 从服务器接收到 UTF-8 编码的数据。       |
| **显示阶段** | UTF-8 → 控制台输出    | UTF-16 (`MultiByteToWideChar` → `wcout`) | 转换为宽字符后，控制台可正确显示中文与 emoji。 |

---

系统地展示了消息的发送与接收流程👇

---

### 🚀 发送（序列化）

| 类型                     | 方法            | 说明                                                                                                                                                                                                                                      |
| ---------------------- | ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **定长消息 (`MSG_LOGIN`)** | 直接发送结构体       | 先填充 `MessageHeader` 和 `LoginRequestBody` 结构体，然后分别调用两次 `send()`：<br>1️⃣ 发送消息头<br>2️⃣ 发送消息体（固定长度）。                                                                                                                                        |
| **变长消息 (`MSG_CHAT`)**  | 构建完整缓冲区再一次性发送 | 先计算总长度：<br>`total_size = sizeof(MessageHeader) + sizeof(ChatRequestBody) + text_len`<br>然后使用 `std::vector<char>` 创建缓冲区，依次使用 `memcpy()` 拷贝：<br>① 消息头 → <br>② 消息体定长部分（`ChatRequestBody`） → <br>③ 消息体变长部分（聊天文本）<br>最后用一次 `send()` 发送整个缓冲区。 |

---

### 📥 接收（反序列化）

| 步骤                          | 方法 / 技术                             | 说明                                                                                                                                               |
| --------------------------- | ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| **1️⃣ 两步接收法**               | `recv()` 两次                         | 先调用一次 `recv()` 读取固定大小的 `MessageHeader`；<br>再根据 `header.bodySize` 确定消息体的精确长度，调用第二次 `recv()` 接收完整的消息体。                                             |
| **2️⃣ 使用 `MSG_WAITALL` 标志** | `recv(sock, buf, len, MSG_WAITALL)` | 告诉 `recv` 一直阻塞，直到收到指定长度的所有数据。这样可以防止 TCP 分包导致的“只收到部分数据”问题。                                                                                        |
| **3️⃣ 数据解析**                | 强制类型转换                              | 当完整接收到消息体后：<br>`ChatRequestBody* body = (ChatRequestBody*)bodyBuffer.data();`<br>即可读取结构体中的字段（如 `username`, `timestamp`）。<br>结构体后紧跟的字节序列就是聊天文本内容。 |

---

### 💡 总体流程示意

| 阶段          | 发送端                   | 网络传输 | 接收端                                       |
| ----------- | --------------------- | ---- | ----------------------------------------- |
| ① 构建消息      | 组装 Header + Body + 文本 | ↓    | —                                         |
| ② 序列化       | `memcpy` → 缓冲区        | ↓    | —                                         |
| ③ 发送        | 一次 `send()` 发送全部      | ↓    | —                                         |
| ④ 接收 Header | —                     | ↓    | `recv(..., sizeof(Header))`               |
| ⑤ 接收 Body   | —                     | ↓    | `recv(..., header.bodySize, MSG_WAITALL)` |
| ⑥ 解析数据      | —                     | ↓    | 类型转换、提取字段与文本                              |

---







# ChatServer.cpp知识点


展示了 TCP 服务器端的核心流程👇

---

### 🧩 TCP 服务器标准工作流程

| 步骤                  | 函数                                                                              | 说明                                                                                                       |
| ------------------- | ------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |
| **1️⃣ 绑定 (bind)**   | `bind(serverSocket, (sockaddr*)&serverAddr, sizeof(serverAddr));`               | 将创建好的 `serverSocket` 与服务器的 IP 地址和端口号绑定。<br>`INADDR_ANY` 表示服务器会在 **所有可用的网卡接口** 上监听连接请求。                   |
| **2️⃣ 监听 (listen)** | `listen(serverSocket, SOMAXCONN);`                                              | 让套接字进入 **被动监听模式**，准备接收客户端的连接请求。<br>`SOMAXCONN` 表示允许的最大排队连接数。                                             |
| **3️⃣ 接受 (accept)** | `SOCKET clientSocket = accept(serverSocket, (sockaddr*)&clientAddr, &addrLen);` | 等待客户端连接。该函数是**阻塞的**：<br>🔹 若无客户端请求连接 → 当前线程暂停执行。<br>🔹 一旦有客户端连接 → 创建并返回一个新的 `clientSocket`，用于与该客户端的后续通信。 |

---

### ⚙️ 典型执行流程示意

| 阶段       | 操作                  | 描述                             |
| -------- | ------------------- | ------------------------------ |
| **初始化**  | `socket()`          | 创建服务器端套接字。                     |
| **绑定**   | `bind()`            | 绑定到本地 IP + 端口（如 0.0.0.0:8888）。 |
| **监听**   | `listen()`          | 启用监听队列，等待客户端连接。                |
| **等待连接** | `accept()`          | 阻塞等待客户端连接，返回新的套接字用于通信。         |
| **通信阶段** | `send()` / `recv()` | 与已连接的客户端进行双向通信。                |
| **关闭连接** | `closesocket()`     | 通信结束后关闭套接字。                    |

---


---

## 🧩 并发服务器模型知识点总结

### 一、整体结构

| 模块      | 功能描述          | 关键代码                                         | 特点            |
| ------- | ------------- | -------------------------------------------- | ------------- |
| 主线程循环   | 持续监听并接受新客户端连接 | `accept(serverSocket, ...)`                  | 阻塞等待，直到有客户端连接 |
| 任务分派    | 创建一个新线程处理客户端  | `std::thread t(HandleClient, clientSocket);` | 每个客户端独立线程     |
| 线程分离    | 主线程不等待子线程执行完  | `t.detach();`                                | 提高响应能力        |
| 客户端处理函数 | 与单个客户端通信      | `recv()`、`send()`、`closesocket()`            | 独立逻辑，互不干扰     |

---

### 二、`accept()` 函数

| 项目   | 说明                                                              |
| ---- | --------------------------------------------------------------- |
| 函数原型 | `SOCKET accept(SOCKET s, struct sockaddr *addr, int *addrlen);` |
| 功能   | 等待客户端请求连接，成功后返回一个新的 socket                                      |
| 行为   | 阻塞（默认），直到有客户端连接到来                                               |
| 返回值  | 新的 `clientSocket`（用于与客户端通信）                                     |
| 特点   | `serverSocket` 仍然用于监听，不会关闭                                      |

---

### 三、`std::thread` 创建新线程

| 项目     | 说明                                           |
| ------ | -------------------------------------------- |
| 创建方式   | `std::thread t(HandleClient, clientSocket);` |
| 功能     | 启动一个新线程并执行函数 `HandleClient(clientSocket)`    |
| 线程生命周期 | 从创建时开始执行，到函数结束时自动退出                          |
| 注意事项   | 参数按值传递时会复制句柄（通常没问题）                          |

---

### 四、`detach()` 与 `join()` 对比

| 方法          | 作用            | 主线程是否等待子线程 | 场景        |
| ----------- | ------------- | ---------- | --------- |
| `.detach()` | 线程与主线程分离，后台运行 | ❌ 否        | 服务器后台持续处理 |
| `.join()`   | 等待线程执行完再继续    | ✅ 是        | 需要同步的任务   |

---

### 五、`HandleClient()` 子线程函数

| 功能   | 示例代码                                             | 说明         |
| ---- | ------------------------------------------------ | ---------- |
| 接收数据 | `recv(clientSocket, buffer, sizeof(buffer), 0);` | 阻塞等待客户端数据  |
| 发送数据 | `send(clientSocket, buffer, bytes, 0);`          | 回发或转发数据    |
| 关闭连接 | `closesocket(clientSocket);`                     | 客户端断开时释放资源 |




---

## 🧩 客户端列表管理 📋

### 一、添加客户端

| 操作     | 说明                                                | 代码示例                                                                                      |
| ------ | ------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| 添加新客户端 | 当用户成功登录后，先上锁，然后将 `ClientInfo` 添加到 `g_clients` 向量中 | `cpp std::lock_guard<std::mutex> lock(g_clients_mutex); g_clients.push_back(newClient); ` |
| 作用     | 保证在多线程环境下对共享向量的安全写入                               | —                                                                                         |

---

### 二、移除客户端（Erase-Remove Idiom）

| 步骤                     | 函数                                                                                           | 说明                                            |
| ---------------------- | -------------------------------------------------------------------------------------------- | --------------------------------------------- |
| **1️⃣ std::remove_if** | `std::remove_if(g_clients.begin(), g_clients.end(), [](const ClientInfo &c){ return 条件; });` | 遍历 vector，将所有不满足条件的元素移动到前面，返回指向“垃圾数据”起始位置的迭代器 |
| **2️⃣ .erase()**       | `g_clients.erase(it, g_clients.end());`                                                      | 一次性删除后面所有“垃圾数据”，完成元素移除                        |

---

### 三、完整示例

```cpp
// 移除已断开的客户端
std::lock_guard<std::mutex> lock(g_clients_mutex);
auto it = std::remove_if(g_clients.begin(), g_clients.end(),
                         [](const ClientInfo &c) { return !c.isConnected; });
g_clients.erase(it, g_clients.end());
```

---

### 四、知识点总结

| 知识点                | 说明                                  |
| ------------------ | ----------------------------------- |
| 多线程安全              | 在访问共享客户端列表时必须上锁（mutex + lock_guard） |
| Erase-Remove Idiom | 高效删除 vector 中满足条件的元素                |
| remove_if          | 逻辑上“标记”需要删除的元素，将其移动到末尾              |
| erase              | 真正删除末尾的垃圾数据，减少 vector 数据移动次数，提高性能   |

---





---

## 🧩 消息广播 📢

### 一、核心功能

| 功能    | 说明                              |
| ----- | ------------------------------- |
| 广播消息  | 将一个客户端发送的消息转发给所有其他客户端           |
| 排除发送者 | 通过 `excludeSocket` 参数，防止消息回发给自己 |

---

### 二、BroadcastBuffer 函数

| 步骤              | 操作                                                   | 说明                 | 代码示例 |
| --------------- | ---------------------------------------------------- | ------------------ | ---- |
| **1️⃣ 上锁**      | `std::lock_guard<std::mutex> lock(g_clients_mutex);` | 保证在广播期间客户端列表不会被修改  | —    |
| **2️⃣ 遍历客户端列表** | `for (auto &client : g_clients)`                     | 遍历每个客户端，准备发送消息     | —    |
| **3️⃣ 排除发送者**   | `if (client.socket != excludeSocket)`                | 消息不会回发给原发送者        | —    |
| **4️⃣ 发送消息**    | `send(client.socket, buffer, size, 0);`              | 向目标客户端 socket 发送消息 | —    |

---

### 三、知识点总结

| 知识点   | 说明                               |
| ----- | -------------------------------- |
| 上锁机制  | 确保多线程环境下遍历与访问共享列表安全              |
| 排除发送者 | 通过 `excludeSocket` 参数实现          |
| 遍历发送  | 遍历每个客户端 socket 并调用 `send()` 发送消息 |
| 核心作用  | 保证聊天室中消息可以广播给所有在线客户端             |

---



